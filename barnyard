#!/usr/bin/env zsh

# Now I want the ability to export the barnyard functions.
#
# This means `barnyard apply`, `barnyard funcs`, `barnyard whever`.
#
# But we don't want to get into serious argument parsing, do we?

___() {
}

# TODO Cannot remember all that I wanted to do with property names, but it seems
# like all I need are the directives and based64 encoding. Maybe include is
# something like `@/modules/postgresql/common`.
export BARNYARD_PATH=${${0:a}%/*}

VERSION=$(zsh $BARNYARD_PATH/barnctl version)

zsh_parse_arguments() {
    local error=${${1:-}:q} context=${${2:-}:q}
    shift 2

    declare -A argument_properties

    local regex short long kind variable default pattern prefix=o_

    while :
    do
        case "$1" in
            -p | --prefix )
                prefix="$2"
                shift 2
                continue
                ;;
            -- )
                shift
                break
                ;;
            * )
                variable=${1%=*}
                [[ "$variable" = "$1" ]] && variable=
                pattern=${1#*=}
                regex='^([a-zA-Z0-9]?),([^@:#]*)([@:#]?)(=.*)?$'
                [[ "$pattern" =~ $regex ]] || { print -R "error definition ${1:q}"; return; }
                short=${match[1]} long=${match[2]} kind=${match[3]} default="${match[4]}"
                if [[ -z "$variable" ]]; then
                    [[ -z "$long" ]] && variable=$prefix$short || variable=$prefix${long//-/_}
                fi
                if [[ "$default" != '' ]]; then
                    case x"$kind" in
                        x )
                            kind=flag
                            [[ "${default:1}" =~ ^[0-1]$ ]] || { print -R "$error $context boolean ${1:q}" && return; }
                            print -R "local $variable=${default:1}"
                            ;;
                        x\! )
                            kind=toggle
                            [[ "${default:1}" =~ ^[0-1]$ ]] || { print -R "$error $context boolean ${1:q})" && return; }
                            print -R "local $variable=${default:1}"
                            ;;
                        x\# )
                            kind=count
                            [[ "${default:1}" =~ ^-?[0-9]+$ ]] || { print -R "$error $context integer ${1:q}" && return; }
                            print -R "local $variable=${default:1}"
                            ;;
                        x: )
                            kind=value
                            print -R "declare -a $variable=( ${default:1:q} )"
                            ;;
                        x@ )
                            { print -R "$error $context no_defaults ${1:q}" && return; }
                            ;;
                    esac
                else
                    case x"$kind" in
                        x )
                            kind=flag
                            print -R "local $variable=1"
                            ;;
                        x\! )
                            kind=toggle
                            print -R "local $variable=0"
                            ;;
                        x\# )
                            kind=count
                            print -R "local $variable=0"
                            ;;
                        x: )
                            kind=value
                            print -R "declare -a $variable"
                            ;;
                        x@ )
                            kind=array
                            print -R "declare -a $variable"
                            ;;
                    esac
                fi
                if [[ -n "$long" ]]; then
                    argument_properties[--${long}]="kind=$kind variable=$variable"
                fi
                if [[ -n "$short" ]]; then
                    argument_properties[-${short}]="kind=$kind variable=$variable"
                fi
                shift
                ;;
        esac
    done

    declare -a args=( "$@" )
    local i=1 arged flag
    while [[ $i -le ${#args[@]} ]]
    do
        case "${args[$i]}" in
            - )
                break
                ;;
            -- )
                let i=i+1
                break
                ;;
            --* )
                arged=1
                regex='^(--[-a-zA-Z0-9]*)(=.*)?$'
                [[ "${args[$i]}" =~ $regex ]] || { print -R "$error $context unknown ${1:q}"; return; }
                long="${match[1]}"
                if [[ "$match[2]" != '' ]]; then
                    arged=0
                    args[i]=${match[2]:1}
                else
                    let i=i+1
                fi
                flag=$long
                [[ -z "${argument_properties[$long]}" ]] && { print -R "$error $context unknown ${short:q}"; return; }
                eval "${argument_properties[$long]}"
                if [[ $kind == toggle && "$long" =~ no- ]]; then
                    print -R "$variable=0"
                fi
                ;;
            -* )
                short="${args[$i]}"
                short="${short:0:2}"
                flag=$short
                [[ -z "${argument_properties[$short]}" ]] && { print -R "$error $context unknown ${short:q}"; return; }
                eval "${argument_properties[$short]}"
                case "$kind" in
                    array | value )
                        if [[ ${#${args[$i]}} -eq 2 ]]; then
                            let i=i+1
                        else
                            args[i]=${${args[$i]}:2}
                        fi
                        ;;
                    * )
                        # TODO If you have args a b and c and you get -abd what
                        # does getopt do? Seems to just append...
                        if [[ ${#args[i]} -gt 2 ]]; then
                            args[i]="-${short:2}"
                        else
                            let i=i+1
                        fi
                        ;;
                esac
                ;;
            *)
                break
                ;;
        esac
        case "$kind" in
            flag | count | toggle )
                [[ $arged -eq 0 ]] && { print -R "$error $context no_args ${flag:q}"; return; }
                ;;
        esac
        case "$kind" in
            flag )
                print -R "$variable=0"
                ;;
            count )
                print -R "let $variable=$variable+1"
                ;;
            toggle )
                print -R "[[ \$$variable -eq 0 ]] && $variable=1 || variable=0"
                ;;
            value )
                print -R "${variable}[1]=${args[$i]:q}"
                let i=i+1
                ;;
            array )
                print -R "${variable}+=(${args[$i]:q})"
                let i=i+1
                ;;
        esac
    done

    [[ $i -eq $(( ${#args[@]} + 1 )) ]] && print -R "set --" || print -R "set -- ${(@)args[$i,-1]:q}"
}

barnyard_argument_error() {
    print -R -u 2 "$@"
    exit 1
}

barnyard_parse_arguments() {
    zsh_parse_arguments barnyard_argument_error "$@"
    echo "[[ \$o_help -eq 0 ]] && usage_$1"
}

IFS=$'\n' read -d '' -r -A BARNCTL_COMMANDS < <( \
    sed -n 's/^barnyard_command_\(.*\)() {$/\1/p' "$BARNYARD_PATH/barnyard" \
)

barnyard_next_command() {
    local prefix=$1 command=$2
    shift 2
    for func in "${BARNCTL_COMMANDS[@]}"; do
        if [[ "$func" == "$prefix$command" ]]; then
            "barnyard_command_$func" "$@"
            return
        fi
    done
    abend <<'    EOF'
        error: no such command \`barnyard ${prefix:gs/_/ }$command\`
    EOF
}

# TODO Can I make these reusable? How about if you run `exec` as program these
# get imported, but if you run `exec` as module they get created by the
# launcher? LOL. Either way they are always there. Oh, wait...
#
# So, maybe exec runs without creating the barnyard environment and putting you
# in that as the working directory. That would be the only difference.
#
# TODO `cd` to the barnyard directory and make that the working directory of a
# barnyard script.

___ barnyard_temporary_directory ___

barnyard_cleanup() {
    [[ -n "$BARNYARD_TEMP" ]] && rm -rf "$BARNYARD_TEMP"
}

barnyard_temporary_directory() {
    [[ -n "$BARNYARD_TEMP" ]] && return
    BARNYARD_TEMP="$(mktemp -d)"
    export BARNYARD_TEMP
}

trap barnyard_cleanup EXIT

___ barnyard_common ___
typeset -A PRIORITY

PRIORITY[panic]=0
PRIORITY[alert]=1
PRIORITY[crit]=2
PRIORITY[err]=3
PRIORITY[warn]=4
PRIORITY[notice]=5
PRIORITY[info]=6
PRIORITY[debug]=7

if [[ -n "$BARNYARD_LOG_LEVEL" ]]; then
    [[ -z "${PRIORITY[$BARNYARD_LOG_LEVEL]}" ]] && abend "invalid log level %s" "$BARNYARD_LOG_LEVEL"
else
    BARNYARD_LOG_LEVEL=info
fi

# An environment variable so someone can set this in their shell.
export BARNYARD_LOG_LEVEL

barnyard_zsh_resource() {
    awk '/^___ '$1' ___/{flag=1;next}/^___/{flag=0}flag' "$BARNYARD_PATH/barnyard"
}

barnyard_write_config() {
    local map=${1:-} file=${2:-}
    declare -a fields
    for key value in "${(@kv)${(P)map}}"; do
        fields+=("${key}=${value}")
    done
    print "${(j:\n:)fields}" > "$file"
}

barnyard_read_config_() {
    local file=${2:-} regex='^([^+=]+)(\+?=)(.*)$' line
    shift 2
    while [[ $# -ne 0 ]]; do
        barnyard_read_config[$1]=${2:-}
        shift 2
    done
    declare -a array
    while read -r line; do
        [[ "$line" =~ $regex ]] || abend bad_config "$config"
        local key=$match[1] element_type=$match[2] value=$match[3]
        case "$element_type" in
            += )
                if (( ${+barnyard_read_config[$key]} )); then
                    array=("${(@Q)${(@z)barnyard_read_config[$key]}}")
                else
                    array=()
                fi
                array+=("$value")
                barnyard_read_config[$key]="${(@qq)${array[@]}}"
                ;;
            = )
                barnyard_read_config[$key]="$value"
                ;;
        esac
    done < "$file"
}

barnyard_get_array() {
    [[ -n "${${(P)1}[$2]}" ]] && : ${(PA)3::=${(@Q)${(@z)${(P)1}[$2]}}}
}

barnyard_read_config() {
    [[ $(( $# % 2 )) == 0 ]] || abend bad_argument_count
    declare -A barnyard_read_config
    barnyard_read_config_ "$@"
    : ${(PA)${1:-reply}::=${(@kv)barnyard_read_config}}
}

barnyard_parse_arguments_() {
    shift
    local regex='^([^=]+)=(.*)$'
    while [[ $# -ne 0 ]]; do
        [[ "$1" =~ $regex ]] || abend bad_argument "$1"
        shift
        barnyard_parse_arguments+=("$match[1]" "$match[2]")
    done
}

__barnyard_parse_arguments() {
    declare -a barnyard_parse_arguments
    barnyard_parse_arguments_ "$@"
    : ${(PA)${1:-reply}::=${(@kv)barnyard_parse_arguments}}
}

abend() {
    log priority=err "$@"
    exit 1
}

log() {
    SALT=a5bbeb04f50fcdee70b0b5976438a8d8

    local priority level
    if [[ -z "${PRIORITY[$1]-}" ]]; then
        priority=info
    else
        priority="$1"
        shift
    fi


    declare -a journald syslog
    local name value regex='^([^=]+)=(.*)$'
    while true; do
        if [[ "$1" =~ $regex ]]; then
            name="${match[1]}" value="${match[2]}"
            journald+=("${name:u}=${value}")
            syslog+=("${name}=${value}")
            if [[ "$name" == priority ]]; then
                priority=$value
            fi
            shift
        else
            break
        fi
    done

    if [[ -n "${o_barnyard[module]}" ]]; then
        journald+=("MODULE=${o_barnyard[module]}")
        syslog+=("module=${o_barnyard[module]}")
    fi

    level=$PRIORITY[$priority]

    if (set +u; [[ "$priority" -gt "${PRIORITY[$BARNYARD_LOG_LEVEL]}" ]]); then
        return
    fi

    local format="$1" message
    shift
    message=$(printf "$format\n" "$@")

    local context=''
    if [[ ${#syslog[@]} -ne 0 ]]; then
        context="; ${(j:, :)syslog}"
    fi

    if [[ -z "$o_barnyard[quiet]" ]]; then
        print -R "$(date --rfc-3339=s | sed 's/+.*//') barnyard[$priority]: $message$context"
    fi

    local id
    id=$(print -R "$SALT" "$format" | md5sum | cut -d' ' -f1)

    journald+=("MESSAGE_ID=$id" "MESSAGE=$message" PRIORITY=$level SYSLOG_FACILITY=1)
    print "${(j:\n:)journald}" | logger --journald
}

barnyard_display() {
    if [[ -z "$o_barnyard[quiet]" ]]; then
        cat /dev/stdin 2>&1
    else
        cat /dev/stdin > /dev/null
    fi
}

barnyard_divider() {
    [[ -n "$o_barnyard[quiet]" ]] && return
    local label="$1"
    local bar=--------------------------------------------------------------------------------
    shift
    local prefix="------- $label "
    print -R "$bar"
    print -R "$prefix ${bar:0:$(( ${#bar} - ${#prefix} - 1 ))}"
    print -R "$bar"
}

barnyard_quotedoc() {
    local heredoc spaces=65536 leading='^( *)([^[:space:]])' IFS='' dedented
    declare -a lines
    while read -r line; do
        lines+=("$line")
        if [[ "$line" =~ $leading ]]; then
            if [[ "${#match[1]}" -lt "$spaces" ]]; then
                spaces="${#match[1]}"
            fi
        fi
    done < /dev/stdin
    read -r -d '' dedented < <(printf "%s\n" "${lines[@]}" | sed -E 's/^ {'$spaces'}//')
    eval "$({
        print -R "cat <<EOF"
        print -R -n "$dedented"
        print -R "EOF"
    })"
}

___
barnyard_version_check() {
    if (( ${#o_version[@]} )); then
        [[ "$o_version[1]" == "$VERSION" ]] || abend "local=$o_version[1]" remote=$VERSION 'version mismatch, please run upgrade'
    fi
}

barnyard_command_functions() {
    eval "$(barnyard_parse_arguments functions h,help -- "$@")"
    barnyard_zsh_resource barnyard_common
}

barnyard_clone() {
    local directory="$BARNYARD_TEMP/$1"
    mkdir -p "$directory"
    if [[ "$o_barnyard[stage]" == production ]]; then
        git -C "$o_registers[barnyard]" archive "${o_barnyard[sha1]}" | tar -C "$directory" -x
    else
        cp -R "$o_registers[barnyard]"/* "$directory"
    fi
}

barnyard_clone_directory() {
    barnyard_temporary_directory

    mkdir -p "$BARNYARD_TEMP/barnyard"
    mkdir -p "$BARNYARD_TEMP/modules"

    barnyard_zsh_resource barnyard_apply > "$BARNYARD_TEMP/apply"
}

barnyard_run() {
    local module

    module=${1:-}

    shift

    barnyard_clone "runs/$module"

    o_barnyard[barnyard]="$BARNYARD_TEMP/runs/$module"
    o_barnyard[configuration]="$o_barnyard[barnyard]/machines/$o_barnyard[hostname]/$module"
    o_barnyard[resources]="$o_barnyard[barnyard]/resources/$o_barnyard[hostname]"
    o_barnyard[age]="$(<"$o_barnyard[barnyard]/age/$o_barnyard[hostname]")" || \
        abend module=$module hostname="$o_barnyard[hostname]" 'age key missing for $%s' "$o_barnyard[hostname]"

    typeset -A o_module

    [[ -e "$o_barnyard[configuration]" ]] || abend 'no configuration for module %s' "$module"
    barnyard_read_config o_module "$o_barnyard[configuration]" _apply once _module "$module"

    mkdir -p /var/lib/barnyard/applied

    local changed=0
    typeset -a applied diffs

    if [[ "$o_barnyard[stage]" == production ]]; then
        case "$o_module[_apply]" in
            always )
                log module="$module" "module % run set to always, applying" "$module"
                ;;
            once )
                if [[ -e "/var/lib/barnyard/applied/$module" ]]; then
                    log module="$module" "already applied module %s" "$module"
                    return 0
                fi
                ;;
            diff | cron )
                if [[ -e "/var/lib/barnyard/applied/$module" ]]; then
                    read -r -A applied < "/var/lib/barnyard/applied/$module"
                    if [[ "$applied[1]" = "$o_barnyard[sha1]" ]]; then
                        log module="$module" "already applied module %s" "$module"
                        return 0
                    fi
                    # Can't use file globs on files that are not there.
                    barnyard_get_array o_module _diff diffs
                    diffs+=("machines/$o_barnyard[hostname]/$module")
                    while read -r file; do
                        for diff in "${diffs[@]}"; do
                            if [[ "$diff" = ^* ]]; then
                                if [[ $file =~ $diff ]]; then
                                    changed=1
                                    break 2
                                fi
                            elif [[ "$diff" = "$file" ]]; then
                                changed=1
                                break 2
                            fi
                        done
                    done < <(git -C "$o_registers[barnyard]" diff --name-only "$applied[1]" "$o_barnyard[sha1]")
                    if ! (( changed )); then
                        log module="$module" "module %s has not changed, skipping" "$module"
                        return 0
                    fi
                    log module="$module" "module %s has changed, re-applying" "$module"
                fi
                ;;
            never )
                log module="$module" "module % run set to never, skipping" "$module"
                return 0
                ;;
        esac
    fi

    o_barnyard[module]="$module"
    export __BARNYARD_O_BARNYARD__="${(@qq)${(@kv)o_barnyard}}"
    export __BARNYARD_O_MODULE__="${(@qq)${(@kv)o_module}}"
    zsh "$BARNYARD_TEMP/apply" "${o_barnyard[barnyard]}/modules/$o_module[_module]/apply.zsh"
    local code=$?
    [[ $code -ne 0 ]] && abend 'module %s exited %d' "${module}" $code

    if [[ "$o_barnyard[stage]" == production ]]; then
        log module="$module" "marking module %s as applied" "$module"
        git -C "$o_registers[barnyard]" log -n 1 --format='%H %at' "$o_barnyard[sha1]" > "/var/lib/barnyard/applied/$module"
    fi
}

barnyard_loop_modules() {
    mkdir -p "/var/lib/barnyard/sha1"

    barnyard_clone_directory

    barnyard_clone configure

    local barnyard="$BARNYARD_TEMP/configure"

    declare -A ordered o_module
    declare -a unordered
    local configuration
    for module in "$@"; do
        configuration="machines/$o_barnyard[hostname]/$module"
        [[ -e "$barnyard/$configuration" ]] || abend 'no configuration for module %s' "$module"
        declare -A o_module
        barnyard_read_config o_module "$barnyard/$configuration" _apply once
        if [[ "$o_module[_order]" ]]; then
            ordered[$module]="$o_module[_order]"
        else
            unordered+=("$module")
        fi
    done

    declare -a in_order
    in_order=(${(f)"$(sort -k1,2 <(for module order in "${(@kv)ordered}"; do echo "$order $module"; done) | cut -d' ' -f2)"})
    in_order+=("${unordered[@]}")

    log info modules="${(j: :)in_order[@]}" 'running modules in order' "${(j: :)in_order[@]}"

    for module in "${in_order[@]}"; do barnyard_run "$module"; done
}

barnyard_configure() {
    local next=${1:-}
    shift

    if [[ ! -e /etc/barnyard/config ]]; then
        abend 'barnyard not installed'
    fi

    typeset -A o_barnyard
    barnyard_read_config o_barnyard /etc/barnyard/config hostname "$(hostname --long)"
    o_barnyard[hostname]=$(hostname --long)
    typeset -A o_registers
    [[ $o_quiet -eq 0 ]] && o_barnyard[quiet]=0
    if [[ -z "$o_develop" ]]; then
        o_barnyard[stage]=production

        export GNUPGHOME=/etc/barnyard/gnupg
        export GIT_SSH_COMMAND='ssh -i /etc/barnyard/id_barnyard -o IdentitiesOnly=yes -o UserKnownHostsFile=/etc/barnyard/known_hosts'

        o_registers[barnyard]=/var/lib/barnyard/repository

        if [[ -e "/var/lib/barnyard/sha1/$o_barnyard[hostname]" ]]; then
            o_barnyard[sha1]=$(<"/var/lib/barnyard/sha1/$o_barnyard[hostname]")
        fi
    else
        o_registers[barnyard]=$(readlink -f "$o_develop")

        [[ -n "$SUDO_USER" ]] || abend 'must run through sudo'
        [[ -e "$o_registers[barnyard]" ]] || abend 'no barnyard at path %s' "${o_barnyard[barnyard]:q}"

        local barnyard_user
        barnyard_user=$(stat -c '%U' "${o_registers[barnyard]}/.git/index") || abend 'not a git repo %s' "$o_registers[barnyard]"

        [[ "$barnyard_user" == $SUDO_USER ]] || abend 'sudo user %s does not own %s' "$SUDO_USER" "${o_barnyard[barnyard]:q}"

        o_barnyard[stage]=development
    fi

    $next "$@"
}

_barnyard_command_apply() {
    declare -a o_modules=( "$@" )

    barnyard_version_check

    if [[ $o_barnyard[stage] == production ]]; then
        git -C "${o_registers[barnyard]}" checkout -q "${o_barnyard[branch]}"
        git -C "${o_registers[barnyard]}" pull -q origin "$branch"

        # We also include the date stamp so that we don't apply a commit that
        # got out of order due to a rebase or merge. Barnyards really ought to
        # be linear and automated, though.

        local sha1
        typeset -a current
        if [[ -n "$o_barnyard[sha1]" ]]; then
            read -r -A current <<< "$(git -C ${o_registers[barnyard]} log -n 1 --format='%H %at' "$o_barnyard[sha1]")"
        fi

        if [[ "${#current[@]}" -eq 0 ]]; then
            while read -r line; do
                read -r -A fields <<< "$line"
                if [[ "${fields[3]}" == G ]]; then
                    checkout=("${fields[@]}")
                    break
                fi
            done < <(git -C "${o_registers[barnyard]}" log --format='%H %at %G?')
        else
            while read -r line; do
                IFS=' ' read -A fields <<< "$line"
                if [[ "${fields[3]}" == G && ${fields[2]} -gt ${current[2]} ]]; then
                    checkout=("${fields[@]}")
                    break
                fi
                if [[ "${fields[1]}" == "${current[1]}" ]]; then
                    break
                fi
            done < <(git -C "${o_registers[barnyard]}" log --format='%H %at %G?')
        fi

        # https://stackoverflow.com/a/21941473
        if [[ "${#checkout[@]}" -ne 0 ]]; then
            o_barnyard[sha1]="${checkout[1]}"
            o_barnyard[stage]=production

            local list="$(ls "${o_registers[barnyard]}/machines/${o_barnyard[hostname]}")"
            declare -a modules=("${(@f)list}")

            barnyard_loop_modules "${modules[@]}"

            echo "${checkout[1]}" > "/var/lib/barnyard/sha1/${o_barnyard[hostname]}"
        fi
    else
        barnyard_loop_modules "${o_modules[@]}"
    fi
}

barnyard_command_apply() {
    eval "$(barnyard_parse_arguments apply v,version: d,develop: q,quiet h,help -- "$@")"
    barnyard_configure _barnyard_command_apply "$@"
}

# Could argue that the repository should never change, but it comes from outside
# and so yes, it could change. You might want to rename your repository, why
# not? It's not immutable like the age or gpg key.

barnyard_command_clone() {
    eval "$(barnyard_parse_arguments clone v,version: h,help -- "$@")"

    barnyard_version_check

    (( $# )) || abend 'a git repository url is required'
    local repository=${1:-}

    [[ -e /etc/barnyard/id_barnyard ]] || abend 'no barnyard ssh key'

    rm -rf /var/lib/barnyard/repository

    export GIT_SSH_COMMAND='ssh -i /etc/barnyard/id_barnyard -o IdentitiesOnly=yes -o UserKnownHostsFile=/etc/barnyard/known_hosts'

    git clone -q "${repository%#*}" /var/lib/barnyard/repository || abend 'unable to clone repository %s' "$repository"

    local branch="${repository##*#}"
    if [[ -z "$branch" ]]; then
        branch=$(git rev-parse --abbrev-ref HEAD) || abend 'unable to determin branch for %s' "$repository"
    else
        git -C /var/lib/barnyard/repository checkout  "$branch" || abend 'unable to checkout branch %s' "$branch"
    fi

    print -R "branch=$branch" > /etc/barnyard/config
}

barnyard_command_commit() {
    eval "$(barnyard_parse_arguments apply v,version: h,help -- "$@")"
    barnyard_version_check
    ( cd /var/lib/barnyard/commit && tar -czf - * | base64 )
}

barnyard_command() {
    echo called
}

# If you want to execute a `zsh` in the `libexec` directory with just the
# environment variables set then invoke it with `/usr/bin/zsh <path>`.

barnyard_command_exec() {
    eval "$(barnyard_parse_arguments exec v,version: h,help -- "$@")"
    barnyard_version_check
    local program=${1:-}
    shift
    if [[ "$program" = /usr/local/libexec/barnyard/*/*.zsh || "$program" != /* ]]; then
        zsh <(barnyard_zsh_resource barnyard_exec) "$program" "$@"
        exit $?
    fi

    "$program" "$@"
    exit $?
}

# Here we add a gpg key. We also need a function to remove a key. We could use
# a Barnyard module to remove a key, but then the user has to have one, write
# one and if a key was compromised they'd want to remove it without running
# Barnyard, because Barnyard could not be trusted until the key was revoked.

barnyard_command_gpg_import() {
    eval "$(barnyard_parse_arguments gpg_import v,version: h,help -- "$@")"

    barnyard_version_check

    (( $EUID == 0 )) || abend 'must be run as root'

    (( $# )) || abend 'a file name is required'

    export GNUPGHOME=/etc/barnyard/gnupg

    local filename=${1:-} gpg_key
    if [[ "$filename" = - ]]; then
        filename=/dev/stdin
    fi
    gpg_key=$(< "$filename") || abend 'unable to read gpg key'

    local fingerprint=$( \
        print -R "$gpg_key" | \
            gpg --with-colons --import-options show-only --import --fingerprint 2>/dev/null | \
            awk -F: '/^fpr/ { print $10; exit }' \
    )

    gpg --import <(print -R "$gpg_key") > /dev/null 2>&1 || abend 'unable to import key'
    gpg --batch --yes --sign-key "$fingerprint" > /dev/null 2>&1 || abend 'unable to sign key'
    gpg --list-keys
}

barnyard_command_gpg() {
    eval "$(barnyard_parse_arguments gpg "h,help" -- "$@")"
    barnyard_next_command gpg_ "$@"
}

barnyard_install_age() {
    cd "$BARNYARD_TEMP"
    curl -sLO https://github.com/FiloSottile/age/releases/download/v1.0.0/age-v1.0.0-linux-amd64.tar.gz
    tar zxf age-v1.0.0-linux-amd64.tar.gz
    find .
    install -m 755 age/age /usr/local/bin/age
    install -m 755 age/age-keygen /usr/local/bin/age-keygen
    age --version
}

barnyard_command_prepare() {
    eval "$(barnyard_parse_arguments prepare "h,help" -- "$@")"
    barnyard_divider 'check gpg'
    gpg --version
    barnyard_divider 'check git'
    git --version
    barnyard_divider 'install age'
    barnyard_temporary_directory
    (barnyard_install_age)
    barnyard_divider 'check age'
    age --version
    barnyard_divider 'check age-keygen'
    age-keygen --version
    barnyard_divider 'generate age key'
    mkdir -p /etc/barnyard
    if [[ ! -e /etc/barnyard/age ]]; then
        age-keygen -o /etc/barnyard/age
    fi
    mkdir -p /var/lib/barnyard/commit/age
    grep '^# public key: ' /etc/barnyard/age | sed 's/# public key: //' | tee /var/lib/barnyard/commit/age/$(hostname --long)
    barnyard_divider 'generate root private key'
    ( umask 077 && mkdir -p /etc/barnyard/gnupg )
    export GNUPGHOME=/etc/barnyard/gnupg
    barnyard_quotedoc <<'    EOF' > "$BARNYARD_TEMP/key_details"
        %echo Generating a basic OpenPGP key
        Key-Type: RSA
        Key-Length: 2048
        Subkey-Type: RSA
        Subkey-Length: 2048
        Name-Real: $(hostname --long)
        Name-Comment: Root Personal Key
        Name-Email: user@$(hostname --long)
        Expire-Date: 0
        %no-ask-passphrase
        %no-protection
        # Do a commit here, so that we can later print "done" :-)
        %commit
        %echo done
    EOF
    gpg --list-keys
    echo --------
    hostname --long
    gpg --list-keys $(hostname --long)
    echo --------
    if ! gpg --list-keys $(hostname --long); then
        gpg --verbose --batch --gen-key "$BARNYARD_TEMP/key_details"
    fi
    gpg --list-keys
}

# We could transfer this age encrypted, but we assume it is comming from
# `barnctl` over SSH or at the very least from a file on the filesystem of the
# host machine.

barnyard_command_ssh_known-hosts() {
    eval "$(barnyard_parse_arguments ssh_known-hosts v,version: h,help -- "$@")"

    barnyard_version_check

    (( $EUID == 0 )) || abend 'must be run as root'

    (( $# )) || abend 'a file name is required'

    local filename=${1:-} gpg_key
    if [[ "$filename" = - ]]; then
        filename=/dev/stdin
    fi

    rm -f /etc/barnyard/id_barnyard

    cat "$filename" > /etc/barnyard/known_hosts

    cat /etc/barnyard/known_hosts
}

barnyard_command_ssh_private-key() {
    eval "$(barnyard_parse_arguments ssh_private-key v,version: h,help -- "$@")"

    barnyard_version_check

    (( $EUID == 0 )) || abend 'must be run as root'

    (( $# )) || abend 'a file name is required'

    local filename=${1:-} gpg_key
    if [[ "$filename" = - ]]; then
        filename=/dev/stdin
    fi

    rm -f /etc/barnyard/id_barnyard

    umask 077
    cat "$filename" > /etc/barnyard/id_barnyard

    ssh-keygen -lf /etc/barnyard/id_barnyard
}

barnyard_command_ssh() {
    eval "$(barnyard_parse_arguments ssh "h,help" -- "$@")"
    barnyard_next_command ssh_ "$@"
}

_barnyard_command_status() {
    declare -A o_module

    barnyard_version_check

    if ! (( $# )); then
        if [[ -z "${o_barnyard[sha1]}" ]]; then
            log 'barnyard not yet applied'
        else
            log 'barnyard applied %s' "${o_barnyard[sha1]}"
        fi
        return 0
    fi

    [[ -z "$o_barnyard[sha1]" ]] && abend 'barnyard not yet applied'

    barnyard_clone_directory

    while (( $# )); do
        o_module[module]="$1"
        o_module[_module]="$1"
        shift

        barnyard_clone "runs/$o_module[module]"

        o_barnyard[barnyard]="$BARNYARD_TEMP/runs/$o_module[module]"
        zsh "$BARNYARD_TEMP/run" "$SCRIPT_DIR/barnyard" "${o_barnyard[barnyard]}/modules/$o_module[_module]/status.zsh"
        echo here && exit 1
    done
}

barnyard_command_status() {
    eval "$(barnyard_parse_arguments status v,version d,develop: h,help -- "$@")"
    barnyard_version_check
    barnyard_configure _barnyard_command_status "$@"
}

barnyard_command_version() {
    eval "$(barnyard_parse_arguments version "h,help" -- "$@")"
    print -R "$VERSION"
}

main() {
    eval "$(barnyard_parse_arguments root h,help -- "$@")"
    barnyard_next_command "" "$@"
}

main "$@"

exit
___ barnyard_apply ___
source <(awk '/^___ barnyard_common ___/{flag=1;next}/^___/{flag=0}flag' "$BARNYARD_PATH/barnyard")

typeset -A o_barnyard=( ${(@Q)${(@z)__BARNYARD_O_BARNYARD__}} ) o_module=( ${(@Q)${(@z)__BARNYARD_O_MODULE__}} )
unset __BARNYARD_O_BARNYARD__ __BARNYARD_O_MODULE__

. "$1"
___ barnyard_exec ___
source <(awk '/^___ barnyard_temporary_directory ___/{flag=1;next}/^___/{flag=0}flag' "$BARNYARD_PATH/barnyard")
source <(awk '/^___ barnyard_common ___/{flag=1;next}/^___/{flag=0}flag' "$BARNYARD_PATH/barnyard")

. "$1"
___
